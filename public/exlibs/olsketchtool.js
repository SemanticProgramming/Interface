/*
 * small script to test using openlayers with DeepZoomService-Api
 */

// first get the json and base url for tiles from DeepZoomService
var getparams;
var serviceUrl = "https://proto.morphdbase.de/deepzoom/api/getZoomify?imageUrl=";
//var serviceUrl = "https://fredie.eu/deepzoom/api/getZoomify?imageUrl=";
var callbackString = "&callback=?";
var imageUrl = "";
var imageprops;

var map; // the map where ol layers are added

var layersdict;

var interactionhandler;
var layerhandler;
var drawinteraction = null;
var interactions = [];

var inverttoggle = false;

// global variables for open layers event conditions
var cond = ol.events.condition.always;
var fhcond = ol.events.condition.shiftKeyOnly;

// call setup to get imageURL parameter and invoke DeepZoomService
//setup


window._isOlSketchToolAlreadySetup = function() {
	return document.getElementById("map").children.length > 0;
};

window._reloadTool = function() {
	$("#map").children().remove();
	getparams = undefined;
	window._setupOlSketchToolOnce();
};

window._setupOlSketchToolOnce = function() {
	if(!window._isOlSketchToolAlreadySetup()) {
		window._setupOlSketchTool();
		console.log("setup old sketch tool");
	}
};

window._setupOlSketchTool = function() {
	//document.getElementById('spinningLoaderDiv').style.display = 'none';
	if ( document.getElementById('spinningLoaderDiv') !== null ) {
		document.getElementById('spinningLoaderDiv').style.display = 'none';
	}

	// close the help
	//$('#ia_help').css('display', 'none');
	// add handler for toggle
	$('#ia_help_button').click(function () {
		$('#ia_help').toggle('slow');
	});

	layerhandler = new LayerHandler();
	interactionhandler = new IAHandler(); // needed during first setup of olviewer, which is called by deepZoomService. This should be fixed Initiate the first interaction independently

	layersdict = new LayersDict(); // needed for storing firts vectorlayer generated by olviewer, which is called by deepZoomService.
	$('#addlayer').click(function () {
		layerhandler.addLayer();
	});
	$('#layerlist').change(function () {
		layerhandler.selectLayer(layersdict, interactionhandler);
	});

	imageUrl = getURLParam();
	//console.log('imageUrl', imageUrl);
	map = deepZoomService(serviceUrl, callbackString, imageUrl);

	// switch to edit-mode when ESC is pressed
	$('body').keydown(function (event) {
		if (event.which == 27) {
			//console.log('set drawtype to Edit?');
			$('input[name="drawtype"][value="Edit"]').prop('checked', true); //$('#layerlist option[value=' + newlayernum + ']').attr('selected',true);
			drawtype = 'Edit'; // set this explicitely, otherwise old value
			interactionhandler.removeInteractions();
			var vlayer = layerhandler.getActiveLayer(layersdict);
			interactions = interactionhandler.addInteraction(vlayer['layerobject'], drawtype);
		}
	});

	// toggle drag & pan on or off, when pressing Space key
	$('body').keydown(function (event) {
		if (event.which == 32) {
			toggleDragPan('off', inverttoggle, drawinteraction);
		}
	});
	$('body').keyup(function (event) {
		if (event.which == 32) {
			toggleDragPan('on', inverttoggle, drawinteraction);
		}
	});


	// handler for deleting selected features
	$('body').keydown(function (event) {
		//console.log(event.keyCode);
		if (event.which == 46) {
			var vlayer = layerhandler.getActiveLayer(layersdict);
			//console.log('vectorlayer edit', vectorlayer);
			myRemoveFeature(vlayer['layerobject'], interactionhandler.selected, layerhandler, false);
		}
	});
	
	// handler for downloading features
	$('#saveGeoJSON').click(function (event) {
		features = collectAllFeatures(layersdict);
		geojson = createGeoJSON(features);
		downloadGeoJSON(geojson);
	});
	
	// handler for uploading features
	//document.getElementById("loadGeoJSON").addEventListener("change", selectFile);
	$('#loadGeoJSON').change(function (event) {
		features = readFile(event, layerhandler);
	});


};


function setcolorindicator(color) {
	var bgcolor = 'rgba(' + color[0] + ', ' + color[1] + ', ' + color[2] + ', 1.0)';
	$('#colorindicator').css({"background-color": bgcolor});
}


// set the color to a new value, dummy called by LayerHandler.addLayer as long as there is no color chooser
function colorshift(color) {
	var i;
	for (i = 0; i < 3; i++) {
		if (color[i] % 2 == 0) {
			color[i] += 121;
		}
		else {
			color[i] += 51;
		}
		if (color[i] > 255) {
			color[i] -= 255;
		}
	}
	var newcolor = color.slice(); //slice with no parameters generates a complete copy of an array, color is changed as base for the next newcolor
	return newcolor;
}


function toggleDragPan (dragonoff, inverttoggle) {

	//test get the browser-event
	var mevent;
	/* mevent = map.on(ol.events.DrawEvent, function () {
		console.log('hello')
	}); */
	//console.log('mevent', mevent, mevent.type, (mevent instanceof ol.interaction.Draw));

	var dragpaninteractions = [];
	var allinteractions = map.getInteractions();
	var drawinteractions = []; // are there more than one drawinteractions? Only if the IAHandler does a bad job!

	allinteractions.forEach(function (ia) {
		if (ia instanceof ol.interaction.DragPan) {
			dragpaninteractions.push(ia);
			//console.log('length dragpaninteractions', dragpaninteractions.length);
		}
		else if (ia instanceof ol.interaction.Draw) {
			// hopefully, there is only one drawinteraction
			drawinteractions.push(ia);
			//console.log('length drawinteractions', drawinteractions.length);
			//console.log(ia, ia.getFeatures())
		}
	});


	// toggle the dragonvalue to the other state if inverttoggle is true
	if (!inverttoggle) {
		inverttoggle = false;
	}

	if (inverttoggle === true) {
		if (dragonoff === 'on') {
			dragonoff = 'off';
		}
		else {
			dragonoff = 'on';
		}
	}

	if (dragonoff === 'off') {
		dragpaninteractions.forEach(function (dpia) {
			dpia.setActive(false);
		});
		if (inverttoggle === true) {
			//ol.events.condition.noModifierKeys;
			drawinteractions.forEach(function (ia) {
				//ia.setActive(true);
				//console.log('props1', ia.getProperties(), ia.getKeys());
				//cond = ol.events.condition.always;
				//fhcond = ol.events.condition.noModifierKey;
			});
		}
		//console.log('toggle drag off 1');
	}
	else if (dragonoff === 'on') {
		dragpaninteractions.forEach(function (dpia) {
			dpia.setActive(true);
		});
		if (inverttoggle === true) {
			//ol.events.condition.never;
			drawinteractions.forEach(function (ia) {
				//ia.setActive(false);
				//console.log('props2', ia.getProperties());
				//cond = ol.events.condition.never;
				//fhcond = ol.events.condition.never;
			});
		}
		//console.log('toggle drag on 2');
	}
}


function myRemoveFeature(vectorlayer, selected, layerhandler, layeronly) {
	// set select options to one or all layers might be easier to understand for user.
	// needs running functions that loops through all layers
	//selected = selectia.getFeatures(); // selectia may be needed to get the layer where the selection is from, therfor selected is not passed directly
	selectedarray = selected.getArray();
	console.log('selectedarray', selected, selectedarray);
	//console.log('getSource', vectorlayer.getSource(), 'selected', selected, selectedarray, 'lentgh', selected.length, selectedarray.length);
	
	
	for (i = selectedarray.length; i--; i >= 0) {
			//console.log(selectedarray.length, i);
			vectorlayer.getSource().removeFeature(selectedarray[i]);
	}
	interactionhandler.removeInteractions();
	interactionhandler.addInteraction(vectorlayer, 'Edit');
}


function IAHandler() {
	this.interactions = [];
	this.selectia = null;
	this.modifyia = null;
	this.drawia = null;
	this.selected = null;
}


IAHandler.prototype = {

	addInteraction: function (vectorlayer, drawtype) {
		// remove possible selections from select interactions
		if (this.selected) {
			this.selected.clear();
			this.selected = null;
		}
		var geomtype = 'None';
		inverttoggle = false;
		toggleDragPan('on', inverttoggle);
		if (drawtype === 'Edit') {
			// restrict the selection to selected layer with {'layers': [vectorlayer]}
			this.selectia = new ol.interaction.Select({'layers': [vectorlayer]});
			map.addInteraction(this.selectia);
			this.selected = this.selectia.getFeatures();
			//console.log('1', this.selectia, this.selected);
			//var selected = this.selected; // no this problems when calling the Eventhandler

			this.modifyia = new ol.interaction.Modify({
				features: this.selected
			});
			map.addInteraction(this.modifyia);


			this.interactions.push(this.selectia);
			this.interactions.push(this.modifia);
		}
		else if (drawtype !== 'None') {
			// take over the drawtype from selection button to set it in geometryName
			geomtype = drawtype;
			var geometryFunction, maxPoints;
			if (drawtype === 'Square') {
				drawtype = 'Circle';
				geometryFunction = ol.interaction.Draw.createRegularPolygon(4);
			}
			if (drawtype === 'Box') {
				drawtype = 'Circle';
				// the drawtpye defines the type of interaction: Circle: stop drawing on ButtonUp, LineString: stop drawing on Double Click?
				geometryFunction = ol.interaction.Draw.createBox();
			}
			// interaction.Draw({type: 'Circle'} produce a circle that can not be read as GeoJSON)
			// conversion with ol.geom.Polygon.fromCircle()
			/*if (drawtype === 'Circle') {
				geometryFunction = ol.interaction.Draw.createRegularPolygon(64);
			}*/
			//console.log ('inverttoggle1', inverttoggle)
			cond = ol.events.condition.always;
			fhcond = ol.events.condition.shiftKeyOnly;
			////////////////////////////////////////////
			// code that does not work because condition on interaction can not be changed and set interaction.setActive(false) deletes the active drawing
			if ((drawtype == 'Fhl') || (drawtype == 'Fha')) {
				cond = ol.events.condition.singleClick; //?
				fhcond = ol.events.condition.noModifierKeys; // this blocks zooming and panning
				inverttoggle = true;
				if (drawtype == 'Fha') {
					drawtype = 'Polygon';
					geomtype = 'Polygon';
				}
				else if (drawtype == 'Fhl') {
					drawtype = 'LineString';
					geomtype = 'LineString';
				}
			}
			//no drawtype Fha/Fhl used
			///////////////////////////////////////////

			this.drawia = new ol.interaction.Draw({
				source: vectorlayer.source,
				type: /** @type {ol.geom.GeometryType} */ (drawtype),
				// settings for draw functions when type is not in: Polygon, LineString
				geometryFunction: geometryFunction,
				geometryName: geomtype,
				maxPoints: maxPoints
				//, these settings block initial freehand drawing
				//condition: cond,
				//freehandCondition: fhcond
			});
			//console.log('vectorlayer ia out', vectorlayer);
			var ikeys = this.drawia.getProperties();
			//console.log('interaction properties', ikeys);
			map.addInteraction(this.drawia);
		}
		this.interactions.push(this.drawia);
		return this.interactions;
	},

	removeInteractions: function () {
		if (this.selected) {
			this.selected.clear();
			//console.log('clear?', this.selected);
			this.selected = null;
		}
		var i;
		for (i = this.interactions.length; i--; i > -1) {
			map.removeInteraction(this.interactions[i]);
			this.selected = null;
			//console.log(this.interactions.length, i, this.selected);
			//this.interactions.pop();
		}
		this.interactions = [];
	}
};


// dictionary to map layers generated by addOlVectorLayer with html-selector values
// could be a simple dictionary, is a class reaaly a good idea?
function LayersDict () {
	this.layerobjs = {};
}

LayersDict.prototype = {
	addLayerObj: function(layernum, layerobj, color) {
		// ad a layernum property to the vectorlayer as the layernum is not known when the vectorlayer is created
		//layerobj.setProperties({
		//	'layernum': layernum,
		//	'color': color
		//});
		
		// add layernum and vectorlayer as objects to a list
		var newlayerobj = {'layerobject': layerobj, 'layercolor': color, 'number': layernum};
		this.layerobjs[layernum] = newlayerobj;
		//console.log('layerobjs', this.layerobjs);
	},

	getLayerObjByNum: function (layernum) {
		//console.log('getter', this.layerobjs[layernum], layernum);
		return this.layerobjs[layernum];
	}
};


// class for handling events triggered by changing layer selector and "add new layer button" in html
function LayerHandler() {
	this.layerlist = [];
	this.layercolor = [102, 255, 204];
}


LayerHandler.prototype = {
	
	addLayer: function(color) {
		this.layerlist = this.getLayers();
		var maxlayernum = 0;
		for (var i=0; i<this.layerlist.length; i++) {
			if (this.layerlist[i]['val'] > maxlayernum) {
				maxlayernum = parseInt(this.layerlist[i]['val']);
			}
		}
		var newlayernum = maxlayernum + 1;
		console.log('newlayernum ', newlayernum);
		// set color
		if (color === undefined) {
			var oldcolor = this.layercolor.slice();
			console.log('oldcolor', oldcolor);
			this.layercolor = colorshift(oldcolor); //colorshift generates new copied color array
			console.log('newcolor', this.layercolor);
		}
		else {
			this.layercolor = color;
		}
		setcolorindicator(this.layercolor);
		$('#layerlist').append(new Option('Object ' + newlayernum, newlayernum)); // does not work with IE?, alternatively: '<option value="' + newlayer + '">Layer ' + newlayer + '</option>'
		$('#layerlist').val(newlayernum);
		vectorlayer = addOlVectorLayer(this.layercolor);
		layersdict.addLayerObj(newlayernum, vectorlayer, this.layercolor);
		interactionhandler.removeInteractions();
		var drawtype = $('input[name="drawtype"]:checked').val();
		interactions = interactionhandler.addInteraction(vectorlayer, drawtype);
	},


	getLayers: function () {
		var layerlist = [];
		$('#layerlist option').each(function (idx, layer) {
			layerlist.push({val: layer.value, text: layer.text, layerobject: layersdict.getLayerObjByNum(layer.value)});
		});
		//console.log(layerlist);
		this.layerlist = layerlist;
		return this.layerlist;
	},

	selectLayer: function(layersdict, interactionhandler) {
		var layernum = $('#layerlist option:selected').val();
		console.log(layernum);
		var activelayer = layersdict.getLayerObjByNum(layernum);
		//console.log ('layersdict', layersdict);
		//console.log ('activelayer', activelayer['layercolor'], activelayer['layerobject']);
		var lcolor = activelayer['layercolor'];
		//console.log('color: ', lcolor);
		setcolorindicator(lcolor);
		var drawtype = $('input[name="drawtype"]:checked').val();
		interactionhandler.removeInteractions();
		interactions = interactionhandler.addInteraction(activelayer['layerobject'], drawtype);
	},

	getActiveLayer: function(layersdict) {
		layernum = $('#layerlist option:selected').val();
		//console.log(layernum);
		var activelayer = layersdict.getLayerObjByNum(layernum);
		return activelayer;
	}
};


function addOlVectorLayer(color) {
	var source = new ol.source.Vector({wrapX: false});
	var vector = new ol.layer.Vector({
		source: source,
		style: new ol.style.Style({
			fill: new ol.style.Fill({
				color: 'rgba(' + color[0] + ', ' + color[1] + ', ' + color[2] + ', 0.4)'
				//'rgba(200, 255, 200, 0.4)' //color
			}),
			stroke: new ol.style.Stroke({
				color: 'rgba(' + color[0] + ', ' + color[1] + ', ' + color[2] + ', 1.0)',
				width: 2
			}),
			image: new ol.style.Circle({
				radius: 7,
				fill: new ol.style.Fill({
					color: 'rgba(' + color[0] + ', ' + color[1] + ', ' + color[2] + ', 1.0)'
				})
			})
		})
	});
	map.addLayer(vector);
	vector.source = source;
	//console.log('this is the source', vector.source);
	return vector;
}



///////////////////////////////////////////////////
// save and load data as GeoJSON
///////////////////////////////////////////////////
function collectAllFeatures(layersdict) {
	featurecollection = [];
	for (var layernum in layersdict.layerobjs) {
		var layer = layersdict.getLayerObjByNum(layernum);
		var vectorlayer = layer['layerobject'];
		var layercolor = layer['layercolor'];
		var featurelist = vectorlayer.getSource().getFeatures();
		console.log('##################', featurelist);
		for (var i=0; i < featurelist.length; i++) {
			featurelist[i].setProperties (
			{
				'layernum': layernum,
				'color': layercolor,
				'geometryName': featurelist[i].getGeometryName()
			});
			// convert the geometry within the feature to polygon when it is a circle. This is needed because 
			// GeoJSON has no circle objects
			// alternatively, circles can be set by created as polygons via a geometryFunction with multiple edges see above in commented part of IAHandler.addInteraction
			// a geometry is an object within a feature
			if (featurelist[i].getGeometryName() == 'Circle') {
				console.log('feature object', featurelist[i]);
				var newpolygon = ol.geom.Polygon.fromCircle(featurelist[i].getGeometry());
				// this sets feature to polygon, thus it can not be read a second time as circle
				//featurelist[i].setGeometry(newpolygon);
				//create a new feature instead
				var newfeature = new ol.Feature(
				{
					geometry: newpolygon
				});
				newfeature.setProperties(
				{
					'layernum': layernum,
					'color': layercolor,
					'geometryName': featurelist[i].getGeometryName(),
					'centercoordinates': featurelist[i].getGeometry().getCenter(),
					'radius': featurelist[i].getGeometry().getRadius(),
				});
				featurecollection.push(newfeature);
			}
			else if ((featurelist[i].getGeometryName() == 'Square') || ((featurelist[i].getGeometryName() == 'Box'))) {
				// I do not know how to create a geometry square or box other than with drawInteraction,
				// thus it can not recreated from json as the circle type 
				// therefore it will be saved with geometryName Polygon
				featurelist[i].setProperties (
				{
					'geometryName': 'Polygon'
				});
				featurecollection.push(featurelist[i]);
			}
			else {
				featurecollection.push(featurelist[i]);
			}
		}
	}
	console.log('featurecollection', featurecollection);
	return featurecollection;
}

function createGeoJSON(featurecollection) {
	format = new ol.format.GeoJSON();
	var geojson = format.writeFeatures(featurecollection, {'decimals': 4});
	console.log('geojson', geojson);
	return geojson;
}

function downloadGeoJSON(geojson) {
	var element = document.createElement('a');
	element.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(geojson));
	element.setAttribute('download', 'features.json');
	element.style.display = 'none';
	document.body.appendChild(element);
	element.click();
	document.body.removeChild(element);
}


function readFile(event, layerhandler) {
	if (event.target.files[0]) {
	var filereader = new FileReader();
	filereader.addEventListener("loadend", function(event) {
		var json = readGeoJSON(event);
			features = loadFeatures(json, layerhandler);
			return features;
		});
	}
	filereader.readAsText(event.target.files[0], "UTF-8");
}

function readGeoJSON(event) {
	var jsonstring = event.target.result;
	var json = JSON.parse(jsonstring);
	return json;
}

function loadFeatures(json, layerhandler) {
	var featurecollection = json['features'];
	for (var i=0; i < featurecollection.length; i++) {
		var feature = featurecollection[i];
		var layernum = feature['properties']['layernum'];
		var color = feature['properties']['color'];
		var layerobj = layersdict.getLayerObjByNum(layernum);
		if (layerobj !== undefined) {
		}
		else {
			layerhandler.addLayer(color);
		}
		appendFeatureFromJSON(feature, layernum);
	}
}

function appendFeatureFromJSON(jsonfeature, layernum) {
	// creates a feature from its representation in GeoJSON
	// doing this by hand is necessary because of my layers construct 
	// and the missing/incompatible coordinate reference system?
	var geometryobj = {};
	var featureobj = {};
	if ((jsonfeature['properties']['geometryName'] === 'Point')) {
		geometryobj = createPoint(jsonfeature);
		featureobj = addFeatureObject(geometryobj, layernum);
		featureobj.setProperties({'geometryName': jsonfeature['properties']['geometryName']});
	}
	if ((jsonfeature['properties']['geometryName'] === 'Polygon')) {
		geometryobj = createPolygon(jsonfeature);
		featureobj = addFeatureObject(geometryobj, layernum);
		featureobj.setProperties({'geometryName': jsonfeature['properties']['geometryName']});
	}
	if ((jsonfeature['properties']['geometryName'] === 'LineString')) {
		geometryobj = createLineString(jsonfeature);
		featureobj = addFeatureObject(geometryobj, layernum);
		featureobj.setProperties({'geometryName': jsonfeature['properties']['geometryName']});
	}
	if ((jsonfeature['properties']['geometryName'] === 'Circle')) {
		console.log('Circle! ', jsonfeature);
		geometryobj = createCircle(jsonfeature);
		featureobj = addFeatureObject(geometryobj, layernum);
		featureobj.setProperties({'geometryName': jsonfeature['properties']['geometryName']});
	}
}

function createPolygon(jsonfeature) {
	var geometryobj = new ol.geom.Polygon(jsonfeature['geometry']['coordinates']);
	return geometryobj;
}

function createLineString(jsonfeature) {
	var geometryobj = new ol.geom.LineString(jsonfeature['geometry']['coordinates']);
	return geometryobj;
}

function createPoint(jsonfeature) {
	var geometryobj = new ol.geom.Point(jsonfeature['geometry']['coordinates']);
	return geometryobj;
}

function createCircle(jsonfeature) {
	var geometryobj = new ol.geom.Circle(jsonfeature['properties']['centercoordinates'], jsonfeature['properties']['radius']);
	return geometryobj;
}

function addFeatureObject(geometryobj, layernum) {
	var featureobj = new ol.Feature(
		{
			'geometry': geometryobj
		}
	);
	var layer = layersdict.getLayerObjByNum(layernum);
	var vectorlayer = layer['layerobject'];
	vectorlayer.source.addFeature(featureobj);
	return featureobj;
}


//////////////////////////////////////////////////
// create an ol.Map instance as viewer for image
// add VectorLayer for drawings, at start only one
//////////////////////////////////////////////////

function olviewer(imageprops) {
	var imgCenter = [imageprops.Width / 2, -imageprops.Height / 2];

	// Maps always need a projection, but Zoomify layers are not geo-referenced, and
	// are only measured in pixels.  So, we create a fake projection that the map
	// can use to properly display the layer.
	var proj = new ol.proj.Projection({
		code: imageprops.format,
		units: 'pixels',
		extent: [0, 0, imageprops.Width, imageprops.Height]
	});

	var zmfsource = new ol.source.Zoomify({
		url: imageprops.Url + "/",
		size: [imageprops.Width, imageprops.Height]
	});

	var raster = new ol.layer.Tile({
		source: zmfsource
	});


	map = new ol.Map({
		layers: [raster],
		target: 'map',

		// add select interaction


		// put it into a viewport
		view: new ol.View({
			projection: proj,
			center: imgCenter,
			zoom: 2, //2, // TODO: change scale
			// constrain the center: center cannot be set outside
			// this extent
			extent: [0, -imageprops.Height, imageprops.Width, 0]
		})
	});

	var color = [102, 255, 204];
	// add a first vector layer onto the map
	vectorlayer = addOlVectorLayer(color);
	//console.log('vectorlayer.source', vectorlayer.source);
	layersdict.addLayerObj(0, vectorlayer, color);
	setcolorindicator(color);
	//console.log(source);
	var drawtype = $('input[name="drawtype"]:checked').val();
	//console.log(drawtype);
	interactions = interactionhandler.addInteraction(vectorlayer, drawtype);

	// add handler for change in drawtype-selector
	$('input[name="drawtype"]').click(function () {
		interactionhandler.removeInteractions();
		drawtype = $('input[name="drawtype"]:checked').val();
		//console.log(drawtype);
		var vlayer = layerhandler.getActiveLayer(layersdict);
		interactions = interactionhandler.addInteraction(vlayer['layerobject'], drawtype);
	});


	return map;
}

////////////////////////////////////////////////
// things for getting tiles from DeepZoomService
////////////////////////////////////////////////

// get the imageURL-parameter
function getURLParam() {
	param = "imageUrl";
	if (getparams == undefined) {
		getparams = parseGETParams();
		if (getparams[param] == undefined) {
			//set dummy image // TODO: change image
			var imagelist = [
				//"https://upload.wikimedia.org/wikipedia/commons/0/08/CSIRO_ScienceImage_6864_Cat_hair_fibre.jpg",
				//"https://physalia.evolution.uni-bonn.de/dumping/Images/ob05_Aoinides_01_LM_007.tif",
				//"https://physalia.evolution.uni-bonn.de/dumping/Images/Planaria_dactyligera.tif",
				//"https://physalia.evolution.uni-bonn.de/dumping/Images/Aphrodita_aculeata.jpg",
				//"https://physalia.evolution.uni-bonn.de/dumping/Images/Priapulus_sp_02.jpg",
				//"https://physalia.evolution.uni-bonn.de/dumping/Images/stainer/prototyp_test_372625_021.tif.jpg",
				//"https://www.morphdbase.de/StorageMedia/images/N_Rudolf/2016/08/N_Rudolf_20160822-M-9.1.jpg",
				//"https://www.morphdbase.de/StorageMedia/images/P_Beckers/2016/02/P_Beckers_20160204-M-56.1.jpg",
				//"https://www.morphdbase.de/StorageMedia/images/Z_FREDIE/2014/05/Z_FREDIE_20140630-M-2570.1.jpg"
				"https://upload.wikimedia.org/wikipedia/commons/7/7c/Flea_%28251_01%29_Aphaniptera%3B_total_preparation.jpg",
				"https://upload.wikimedia.org/wikipedia/commons/0/06/Felis_silvestris_catus_-_skeleton_-_MUSE.JPG",
				"https://upload.wikimedia.org/wikipedia/commons/1/12/Caliphrodae_head.jpg",
				"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/Red_Blood_Cell_in_capillary.tif/lossy-page1-600px-Red_Blood_Cell_in_capillary.tif.jpg",
				"https://upload.wikimedia.org/wikipedia/commons/4/46/Hazelnut_%28male_flower%29%2C_overlay_of_7_channel_autofluorescence_microscopy_%2830458886372%29.jpg",
				"https://upload.wikimedia.org/wikipedia/commons/thumb/f/fd/Middle_tibia_of_orchid_bee_%28Apidae%2C_Eufriesea_schmidtiana_%28Friese%29%29_%2837162867732%29.jpg/1280px-Middle_tibia_of_orchid_bee_%28Apidae%2C_Eufriesea_schmidtiana_%28Friese%29%29_%2837162867732%29.jpg",
				"https://upload.wikimedia.org/wikipedia/commons/thumb/1/17/Mus_musculus_spretus_MWNH_1381.jpg/1280px-Mus_musculus_spretus_MWNH_1381.jpg"
			];
			var listlength = imagelist.length;
			var randelement = Math.floor(Math.random() * (listlength - 0)) + 0; //min and max values: min = 0, max = 4 for random number generator
			console.log(randelement, imagelist[randelement]);
			getparams[param] = [imagelist[randelement]];
		}
	}
	return getparams[param][0]; //works as long as only one parameter is used per key
}

function parseGETParams() {
	// get the parameters from calling url
	getparams = {};
	if (document.location.search) {
		var paramslist = window.location.search.substr(1).split('&');
		//console.log('plist = ', paramslist);
		if (paramslist.length > 0) {
			for (var i = 0; i < paramslist.length; i++) {
				var pair = paramslist[i].split('=');
				var key = decodeURIComponent(pair[0]);
				var value = decodeURIComponent(pair[1]);
				//console.log('key = ', pair[0], 'value = ', pair[1]);
				// generate list for each key in case that several parameters have the same key
				if (getparams[key] == undefined) {
					getparams[key] = [value];
				}
				else {
					getparams[key].push(value)
				}
			}
		}
	}
	return getparams;
}

// call deepzoomservice to generate tiles and get url to tiles directory
// call openlayers when deepzoomservice call was successful
function deepZoomService(serviceUrl, callbackString, imageUrl) {
	var imageprops;
	var url = serviceUrl + imageUrl + callbackString;
	//console.log(url);
	// get the json strem with image properties and base url
	$.ajax(url,
		{
			username: 'dz_user',
			password: 'pi2aeMic',
			dataType: 'json'

		})

		.done(function (json) {
			imageprops = json;
			//console.log('imageprops', imageprops);
			map = olviewer(imageprops);
			return map;
		})
		.fail(function (jqxhr, textStatus, error) {
			var err = textStatus + ", " + error;
			console.log("Request Failed: " + err);
		});
}
